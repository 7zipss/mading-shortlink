| **对比维度** | **主链路消费 (ShortLinkStatsSave)**                          | **延迟重试消费 (DelayShortLinkStats)**                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心职责** | **数据落地**：负责将高并发的访问数据写入数据库。             | **避让重试**：处理因锁竞争失败的消息，暂存并重新投递。       |
| **底层组件** | **Redis Stream** (基于 Redis 5.0+ 原生 Stream 结构)          | **Redisson DelayQueue** (基于 Redis ZSet + List 封装)        |
| **消费模式** | **推 (Push) / 被动接收** 基于 `StreamListener` 接口，由容器自动回调。 | **拉 (Pull) / 主动轮询** 启动后台死循环线程，不断执行 `poll()` 拉取。 |
| **线程模型** | **容器线程池** 由 `StreamMessageListenerContainer` 管理的线程池调度。 | **单线程守护** 通过 `Executors.newSingleThreadExecutor` 手动启动。 |
| **消息载体** | **`Map<String, String>`** 扁平化的键值对结构，需反序列化。   | **`ShortLinkStatsRecordDTO`** 完整的 Java 对象，包含生成的唯一 Key。 |
| **业务流向** | 消息 -> **解析** -> **写数据库** (终点)                      | 消息 -> **等待** -> **发回主 Stream** (回环)                 |
| **触发时机** | 用户访问短链接时立即触发。                                   | 主消费者尝试获取锁失败时触发。                               |
| **主要代码** | `ShortLinkStatsSaveConsumer.java`                            | `DelayShortLinkStatsConsumer.java`                           |

### 详细机制解析

#### 1. ShortLinkStatsSave (主干道)

- **设计目标**：高性能、高吞吐。
- **工作方式**：它是系统的“大动脉”。所有用户的访问请求都会第一时间转化为消息进入这里。它不关心重试逻辑，只专注于把数据快速、批量地写入数据库的 9 张表中。
- **关键特性**：使用了 **Redis Stream**，这是一种类似于 Kafka 的日志型队列，支持消费者组（Consumer Group），允许多个服务实例分摊消费压力，且具备消息持久化能力。

#### 2. DelayShortLinkStats (应急车道)

- **设计目标**：数据一致性、并发冲突解决。
- **工作方式**：它是系统的“兜底机制”。只有当主消费者发现当前短链接正在被修改（持有写锁）时，才会把消息扔到这里。
- **关键特性**：
  - **延迟特性**：利用 Redisson 的延迟队列，让消息“冷静” 5 秒钟，等待写锁释放。
  - **循环重试**：它不直接写库，而是把消息**重新发回主 Stream**。这意味着如果 5 秒后锁还没释放，消息会被再次扔回延迟队列，形成 `Stream -> Delay -> Stream` 的重试闭环，直到成功入库。

### 总结

这套架构通过 **Stream 处理正常流量** + **DelayQueue 处理异常/冲突流量** 的组合，完美实现了高并发场景下的**削峰填谷**与**数据最终一致性**。